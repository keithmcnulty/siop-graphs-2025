---
title: "The Awesome Analytic Power of Graphs"
authors:
  - Keith McNulty & Rachel Ramsay, McKinsey & Company
format: 
  revealjs:
    theme: ["pp.scss"]
    slide-number: c/t
    incremental: true
    highlight-style: github
    title-slide-attributes:
      data-background-image: img/SIOP-cover-background.png
      data-background-size: cover  
editor: source
---


# What are graph databases? {background-image="img/SIOP-section-background.png" background-size="cover"}

And why should we use them?

## Traditional databases {background-image="img/SIOP-darkred-background.png" background-size="cover"}

Traditional (SQL) databases store data in tables with rows and columns, in order to be efficient at indexing **records**.  For example, if we want to get all employees currently in a given department, we might run a query like this:

```
SELECT departmentCode, employeeId
FROM employee_table
WHERE departmentCode = 12546
AND recordDate = '2025-10-24';
```

and this might return something like:

```{r}
(example <- data.frame(
  departmentCode = c(12546, 12546, 12546, 12546, 12546),
  employeeId = c(1000345, 1001465, 1002698, 1007365, 1001656)
))
```


<div style="background: url(img/trad-database.png) no-repeat center center;
                        background-size: cover;
                        position: absolute;
                        top: 5px;
                        right: 55px;
                        width: 75px;
                        height: 75px;"></div>

## Limitations of traditional databases  {background-image="img/SIOP-brightred-background.png" background-size="cover"}

Database querying can be complex and inefficient when you are interested in **relationships** in your data. For example, if you wanted to find pairs of related employees based on whether they have worked in the same department at any time in the past, the SQL might look something like:

```
SELECT DISTINCT t1.employeeId, t2.employeeId, t1.departmentCode
FROM (
  SELECT departmentCode, employeeId, recordDate
  FROM employee_table
) t1, (
  SELECT departmentCode, employeeId, recordDate
  FROM employee_table
) t2
WHERE t1.departmentCode = t2.departmentCode
AND t1.employeeId <> t2.employeeId
AND t1.recordDate = t2.recordDate;
```

This is still quite simple, but onerous to perform using traditional SQL queries.  More complex queries on relationships can be even more difficult to write and execute.

<div style="background: url(img/trad-database.png) no-repeat center center;
                        background-size: cover;
                        position: absolute;
                        top: 5px;
                        right: 55px;
                        width: 75px;
                        height: 75px;"></div>



## Graph databases {background-image="img/SIOP-darkgrey-background.png" background-size="cover"}

:::rows
:::row
:::column

If you are performing a lot of analysis on relationships between entities, you
should transform your data and store it in a graph database.</p>  

Graph databases store data as **nodes** (entities) and **edges** (relationships between entities).
Using the Cypher graph query language as an example, the previous query would now look like:
:::

:::column
<br>
```{r, out.height = "200px", out.width = "300px"}
#| echo: FALSE

library(igraph)
library(ggraph)

edgelist <- data.frame(
  from = c("e1", "e2"),
  to = c("d", "d")
)

example_graph <- igraph::graph_from_data_frame(edgelist, directed = TRUE)

V(example_graph)$color <- ifelse(
  V(example_graph)$name %in% c("e1", "e2"), "lightblue", "pink"
)

V(example_graph)$type <- ifelse(V(example_graph)$name %in% c("e1", "e2"),
                          "Employee", 
                          "Department")



# more visible edges 
E(example_graph)$width <- 3
E(example_graph)$label <- "WORKED_IN -->"

set.seed(123)

ggraph(example_graph, layout = "eigen") +
  geom_edge_link(aes(label = label), 
                 angle_calc = 'along',
                 label_dodge = unit(2.5, 'mm'),
                 arrow = arrow(length = unit(4, 'mm')), 
                 end_cap = circle(3, 'mm'), 
                 label_size = 6) + 
  geom_node_point(aes(color = as.factor(type)), size = 20, 
                  show.legend = FALSE) +
  labs(color = "Type") +
  ylim(-1, 1) +
  xlim(-1, 1) +
  geom_node_text(aes(label = paste0(name, ": ", type)), nudge_y = -0.2, size = 6) +
  theme_void()
```
:::
:::

::: row


```
MATCH (e1:Employee)-[r1:WORKED_IN]->(d:Department)<-[r2:WORKED_IN]-(e2:Employee)
WHERE e1.employeeId <> e2.employeeId 
AND r1.recordDate = r2.recordDate
RETURN DISTINCT e1.employeeId, e2.employeeId, d.departmentCode;
```
:::
:::




<div style="background: url(img/graph-database.png) no-repeat center center;
                        background-size: cover;
                        position: absolute;
                        top: 5px;
                        right: 55px;
                        width: 100px;
                        height: 100px;"></div>



## Example technologies {background-image="img/SIOP-lightgrey-background.png" background-size="cover"}

::: columns

::: column

<center>
Labeled Property Graph (LPG):

![](img/lpgs.png){height=400 fig-align="center"}
</center>


::: 

::: column

<center>
Resource Description Framework (RDF):

![](img/rdfs.png){height=400 fig-align="center"}
</center>

:::

:::

<div style="background: url(img/graph-database.png) no-repeat center center;
                        background-size: cover;
                        position: absolute;
                        top: 5px;
                        right: 55px;
                        width: 100px;
                        height: 100px;"></div>
                        
# Graph DBs in the wild {background-image="img/SIOP-section-background.png" background-size="cover"}

A very quick overview of scaled use cases

## Test {background-image="img/SIOP-darkred-background.png" background-size="cover"}



# A recent graph breakthrough {background-image="img/SIOP-section-background.png" background-size="cover"}

How we solved the question of time use

## Test {background-image="img/SIOP-darkred-background.png" background-size="cover"}

